from fastapi import FastAPI, HTTPException, Depends, WebSocket
from pydantic import BaseModel
from typing import List
import base64
from app.auth.jwt_handler import get_current_user
from app.services.ai_service import generate_product_description, generate_tags, categorize_ewaste_image, decide_recycle_or_resell, give_ques, websocket_endpoint
app = FastAPI()
class DescriptionInput(BaseModel): 
    """Model for receiving text input from users."""
    prod_desc_by_user: str

class DescriptionResponse(BaseModel):
    """Response model for AI-generated product description."""
    description: str

class BlogDataInput(BaseModel):
    """Model for receiving text input from users."""
    blog: str

class BlogDataResponse(BaseModel):
    """Model for AI-generated tags for blogs."""
    tags: List[str]

class ImageDataInput(BaseModel):
    """Model for receiving base64-encoded images."""
    image_base64: str

class QuestionGetterInput(BaseModel):
    """Model for receiving title name for generating questions."""
    title: str

class DecisionInput(BaseModel):
    """Model for decision-making based on product name and Q&A."""
    title: str
    initial_prod_description: str
    qnas: str  # Serialized list of answers from the user

class DecisionResponse(BaseModel):
    """Response model for item decision (Recycle or Resell)."""
    decision: str
    # guide: dict  # Optional additional guidance if applicable
    guide: dict

class ImageDataResponse(BaseModel):
    """Response model for e-waste categorization."""
    title: str
    desc: str
    search_tags: List[str] | None = None
    category: str

class QuestionGetterResponse(BaseModel):
    """Response model for AI-generated questions."""
    questions: List[str]

@app.post("/ai/generate_description", response_model=DescriptionResponse)
async def generate_description(data: DescriptionInput, current_user: dict = Depends(get_current_user)):
    """
    Generate a product description from user input.
    - **prod_desc_by_user**: Text of description of the product.
    - **Returns**: A dictionary containing the AI-generated description.
    """
    try:
        return DescriptionResponse(description=generate_product_description(data.prod_desc_by_user))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/ai/generate_blog_tags", response_model=BlogDataResponse)
async def generate_tags_endpoint(data: BlogDataInput, current_user: dict = Depends(get_current_user)):
    """
    Generate relevant search tags from user input.
    - **blog**: Text of the blog.
    - **Returns**: A dictionary containing a list of AI-generated tags.
    """
    try:
        return BlogDataResponse(tags=generate_tags(data.blog))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/ai/categorize_ewaste_base64", response_model=ImageDataResponse)
async def categorize_e_waste_base64(image_data: ImageDataInput, current_user: dict = Depends(get_current_user)):
    """
    Categorize an e-waste item based on an image.
    - **image_base64**: Base64-encoded image.
    - **Returns**: A dictionary with title, description, search tags, and generic tag.
    """
    try:
        image_bytes = base64.b64decode(image_data.image_base64)
        c=categorize_ewaste_image(image_bytes)
        return ImageDataResponse(title=c['category'],desc=c['desc'],search_tags=c['search_tags'],category=c['category'])
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/ai/get_questions", response_model=QuestionGetterResponse)
async def gen_ques(data: QuestionGetterInput, current_user: dict = Depends(get_current_user)):
    """
    Generate relevant questions based on the product name.
    - **title**: Name of the product.
    - **Returns**: A list of AI-generated questions.
    """
    try:
        return QuestionGetterResponse(questions=give_ques(data.title)['questions'])
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.websocket("/chatlv")
async def chat_endpoint(websocket: WebSocket):
    """WebSocket endpoint for live chat functionality."""
    try:
        await websocket_endpoint(websocket)
    except Exception as e:
        await websocket.close()

@app.post("/ai/decide", response_model=DecisionResponse)
async def decide_resell_or_recycle(data: DecisionInput, current_user: dict = Depends(get_current_user)):
    """
    Decide whether a product should be recycled or resold.
    - **title**: Name of the product.
    - **initial_prod_description**: Initial product description generated by AI after clicking the photo.
    - **qnas**: List of answers related to the product's condition.
    - **Returns**: Decision ('recycle' or 'resell') with optional guidance in JSON format.
    """
    try:
        decision = decide_recycle_or_resell(data.title, data.initial_prod_description, data.qnas)
        return DecisionResponse(decision=decision["r"], guide=decision["g"])
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    


